**Effective Modern C++读书笔记**

# 一、型别推导
## 1.理解模板型别推导
- 在模板型别推导过程中，具有引用型别的实参会被当成非引用型别来处理。换言之，其引用会被忽略。
- 对万能引用形参进行推导时，左值实参会进行特殊处理。（左值会被推导为左值引用）
- 对按值传递的形参进行推导时，若实参型别中带有const或volatile饰词，则它们还是会被当作不带const或volatile饰词的型别来处理。
- 在模板型别推导过程中，数组或函数型别的实参会退化成对应的指针，除非它们被利用来初始化引用。
## 2.理解auto型别推导
- 在一般情况下，auto型别推导和模板型别推导是一模一样，但是auto型别推导会假定用大括号括起的初始化表达式代表一个std::initializer_list，但模板型别推导却不会
- 在函数返回值或lambda的形参中使用auto，和使用模板型别推导一致而非auto型别推导，即返回值为`{}`不能使用auto
## 3.理解decltype
- 绝大多数情况下，decltype会得出变量或表达式的型别而不作任何修改
- 对于型别为T的左值表达式，除非该表达式仅有一个名字，decltype总是得出型别T&
- C++14支持decltype(auto)，和auto一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是decltype的规则
```C++
    std::vector<int> vec { 1, 2, 3, 4, 5 };
    decltype(vec[0]) v0 = vec[0]; // v0类型为 int&
    decltype(auto) v1   = vec[1]; // v1类型为 int&
    auto v2             = vec[2]; // v2类型为 int
```
## 4.掌握查看型别推导结果的方法
- 利用IDE编辑器、编译器错误消息和Boost.TypeIndex库常常能够查看到推导而得到的型别
- 有些工具产生的结果可能会无用，或者不准确。所以，理解C++型别推导规则是必要的
# 二、auto
## 5.优先选用auto，而非显式型别声明
- auto变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显示指定型别要少打一些字
## 6.当auto推导的型别不符合要求时，使用带显式型别的初始化物习惯用法
- “隐形”的代理型别可以导致auto根据初始化表达式推导出“错误的”型别，例如`std::vector<bool>.operator[]`
- 带显式型别的初始化物习惯用法强制auto推导出你想要的型别，`auto val = static_cast<T>(expr);`
# 三、转向现代C++
## 7.在创建对象时注意区分()和{}
```C++
std::vector<int> vec1{10, 20}; // 两个元素10和20
std::vector<int> vec2(10, 20); // 10个值为20的元素

template<typename T, typename... Args>
void Func(Args&&... args)
{
    // 利用args构造T
    T t1(std::forward<Args>(args)...);
    T t2{std::forward<Args>(args)...};

    // 典型示例：
    std::make_unique
    std::make_shared
}

class T
{
public:
    // 类有std::initializer_list类型的参数作为构造函数和没有时
    // T t{};
    T(std::initializer_list<int>)
}
```
## 8.优先选用nullptr，而非0或NULL
- 避免在整形和指针型别之间重载，std::nullptr_t可以隐式转换到所有指针型别
```C++
#define NULL 0
#define NULL 0L
#define NULL ((void *)0)
```
## 9.优先选用别名声明而非typedef
- typedef不支持模板化，但是别名声明支持
- 在模板内，对于内嵌typedef的引用经常要求加上typename前缀
## 10.优先选用限定作用域的枚举型别，而非不限定作用域的枚举型别
- 不限范围的枚举型别中的枚举量可以隐式转换到整形型别，并能够从此处进一步转换到浮点型别等
- enum class总是可以前置声明（默认型别是int），enum只有指定了默认底层型别的前提下才可以前置声明
- enum可以用来当作`std::get<Enum>(tuple)`的模板参数
## 11.优先选用删除函数，而非private未定义函数
- 习惯上，删除函数一般被声明为public，编译器会提供有更好的错误信息、
- 删除函数可以让参数隐式转换失败
- 删除函数可以阻止不应该进行的模板具现
- 任何函数都可以删除，包括非成员函数和模板具现
```C++
// 隐式转换失败
void Func(int){}
void Func(float) = delete
Func(1.f); // error

// 阻止模板具现
template<typename T>
void Func(T*){}

template<>
void Func<void>(void*) = delete;
```
## 12.为意在改写的函数添加override声明
- 子类中重写的函数都应该添加override声明
- 成员函数引用饰词使得对于左值和右值对象(*this)的处理能够区分开来
## 13.优先选用const_iterator，而非iterator
- 优先选用非成员函数版本的begin()、end()和rbegin()等函数
```C++
std::begin(container);
std::end(container);

template<class C>
auto cbegin(const C& con) -> decltype(std::begin(con))
{
    // 注意此处是std::begin()
    return std::begin(con);
}
```
## 14.只要函数不会发射异常，就为其加上noexpect声明
- 异常中立函数（自身不抛异常，调用的函数会抛出异常）不具备noexcept性质，大多数函数是异常中立的
- 只要能确保函数不抛出异常，就一定要加上noexcept
- noexcept性质对于移动操作、swap、内存释放函数和析构函数最有价值
- delete、delete[]、析构函数等从C++11开始隐式的具备noexcept性质
## 15.只要有可能使用constexpr，就使用它
- 所有constexpr对象都是const对象，而并非所有的const对象都是constexpr对象
- constexpr对象都具备const属性，并由编译期已知的值完成初始化
## 16.保证const成员函数的线程安全性
- 带有const的成员函数应该线程安全
- 运用std::atomic型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作
## 17.理解特种成员函数的生成机制
- 特种成员函数是指那些C++会自动生成的函数：默认构造函数、析构函数、复制操作、移动操作
- 移动操作只有在用户没有显式声明复制操作、移动操作以及析构函数时才会自动生成
- 只要没有显式声明拷贝赋值和移动操作就会自动生成拷贝赋值，拷贝构造同理
- 在已经存在显式声明析构函数的条件下，生成复制操作已经成为了废弃行为
- 成员函数模板在任何情况下都不会抑制特种成员函数的生成
- 三五零法则
# 四、智能指针
## 18.使用std::unique_ptr管理具备专属所有权的资源
- std::unique_ptr是小巧的、高速的、具备只移型别的智能指针，对托管资源实施专属所有权语义
- 默认地，资源析构采用delete运算符来实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加std::unique_ptr型别对象的尺寸
- 将std::unique_ptr转换为std::shared_ptr是容易实现的。
## 19.使用std::shared_ptr管理具备共享所有权的资源
- std::shared_ptr提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收
- 与std::unique_ptr相比，std::shared_ptr的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用计数操作
- 默认的资源析构通过delete运算符进行，但同时也支持定制删除器。删除器的型别对std::shared_ptr的型别没有影响
- 避免使用裸指针型别的变量来创建std::shared_ptr指针
## 20.对于类似std::shared_ptr但有可能空悬的指针使用std::weak_ptr
- 使用std::weak_ptr来替代可能空悬的std::shared_ptr
- std::weak_ptr可能的用武之地包括缓存，观察者列表，以及避免std::shared_ptr指针环路
## 21.优先选用std::make_unique和std::make_shared，而非直接使用new
- 相比于直接使用new表达式，make系列函数消除了重复代码、改进了异常安全性，并且对于std::make_shared和std::make_allocated_shared而言，生成的目标代码会尺寸更小，速度更快
- 不适于使用make系列函数的场景包括需要定制删除器，以及期望直接传递大括号初始化物
- 对于std::shared_ptr，不建议使用make系列函数的额外场景包括：
    1. 自定义内存管理的类
    2. 内存紧张的系统、非常大的对象、以及存在比指向到相同对象的std::shared_ptr生存期更久的std::weak_ptr
## 22.使用Pimpl惯用法时，将特殊成员函数的定义放到实现文件中
- Pimpl惯用法通过降低类的客户和类的实现者之间的依赖性，减少了构建遍数。
- 对于采用std::unique_ptr来实现的Pimpl指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们，即使默认函数实现有着正确行为，也必须这样做
- 上述建议仅适用于std::unique_ptr，但并不适用std::shared_ptr

Visual Studio报错：can't delete an incomplete type 解决方法：将类的构造函数和析构函数在cpp文件中实现
# 五、右值引用、移动语义和完美转发
`void Func(Object&& obj);` obj是一个左值，obj的型别是Object&&
## 23.理解std::move和std::forward
- std::move实施的是无条件的向右值型别的强制型别转换。就其本身而言，它不会执行移动操作。
- 仅当传入的实参被绑定到右值时，std::forward才针对该实参实施向右值型别的强制型别转换
- 在运行期，std::move和std::forward都不会做任何操作
- 不要对一个常量使用std::move，因为对常量使用std::move其实就是使用复制操作
## 24.区分万能引用和右值引用
- 如果函数模板形参具备T&&型别，并且T的型别系推导而来，或如果对象使用auto&&声明其型别，则该形参或对象就是个万能引用
- 如果型别声明并不精确地具备type&&的形式，或者型别推导并未发生，则type&&就代表右值引
- 涉及型别推导是万能引用的必要条件，但不是充分条件，例如`template<typename T> void Func(std::vector<T>&&)`形参的型别是右值引用并不是万能引用
- 若采用右值来初始化万能引用，就会得到一个右值引用。若采用左值来初始化万能引用，就会得到一个左值引用
## 25.针对右值引用实施std::move，针对万能引用实施std::forward
- 针对右值引用的最后一次使用实施std::move，针对万能引用的最后一次使用实施std::forward
- 作为按值返回的函数的右值引用和万能引用，依上一条所述采取相同行为
- 若局部对象可能适用于返回值优化（RVO），则请勿针对其实施std::move或std::forward
## 26.避免依万能引用型别进行重载
- 尽可能避免把万能引用作为函数重载的形参选项
- 完美转发构造函数的问题尤为严重，因为对于非常量的左值型别而言，它们一般都会形成相对于复制构造函数的更佳匹配，并且它们还会劫持派生类中对基类的复制和移动构造函数的调用
## 27.熟悉依万能引用型别进行重载的替代方案
- 如果不使用万能引用和重载的组合，则替代方案包括使用彼此不同的函数名字、传递`const T&`型别的形参、传值和标签分派
- 经由std::enable_if对模板施加限制，就可以将万能引用和重载一起使用，不过这种技术控制了编译器可以调用到接受万能引用的重载版本的条件
- 万能引用形参通常在性能方面具备优势，但在易用性方面一般会有劣势
## 28.理解引用折叠
- 引用折叠会在四种语境中发生：模板实例化、auto型别生成、创建和运用typedef和别名声明，以及decltype
- 当编译器在引用折叠的语境下生成引用的引用时，结果会变成单个引用。如果原始的引用中有任一引用为左值引用，则结果为左值引用。否则，结果为右值引用
- 万能引用就是在型别推导的过程会区别左值和右值，以及会发生引用折叠的语境中的右值引用
## 29.假定移动操作不存在、成本高、未使用
- 以下几种情况下移动语义并不会带来好处
    - 没有移动操作：待移动的对象未能提供移动操作
    - 移动不能更快：待移动的对象虽然支持移动操作，但并不比其复制操作更快，例如std::array
    - 移动不可用：移动本可以发生的情况下，要求移动操作不可发射异常，但该操作为加上noexpect声明，std::move_if_noexpect 
- 源对象是个左值时，绝大多数情况下也不能提供效率增益，RVO
## 30.熟悉完美转发的失败情形
- 完美转发的失败情形，是源于模板型别推导失败，或推导结果是错误的型别
- 会导致完美转发失败的实参种类有大括号初始化物、以值0或NULL表达的空指针、仅有声明的整形static const成员变量、模板或重载的函数名字，以及位域
# 六、lambda表达式
## 31.避免默认捕获模式
- 按引用的默认捕获会导致空悬指针问题
- 按值的默认捕获极易受空悬指针影响（尤其是this），并会误导人们认为lambda是自洽的
- static变量是无法被捕获的，能捕获编译器也会有警告，在lambda内使用static变量，相当于引用捕获
## 32.使用初始化捕获将对象移入闭包
- 使用C++14的初始化捕获将对象移入闭包
- 在C++11中，经由手工实现的类或std::bind去模拟初始化捕获
```C++
    Object obj;

    // = 左边的obj作用域是lambda表达式内部，它是由右边的obj通过拷贝构造而来
    auto f = [obj = obj](){};

    // 左边的obj是由右边的obj移动构造而来，可以用来捕获std::unique_ptr，std::thread等只移型别
    auto f = [obj = std::move(obj)](){};
```
## 33.对auto&&型别的形参使用decltype，以std::forward之
- `std::forward<T>()`的模板列表使用`decltype(arg)`，无需区分左值和右值
## 34.优先选用lambda，而非std::bind
- lambda比起使用std::bind而言，可读性更好、表达力更强，运行效率也可能更高
- 仅在C++11中，std::bind在实现移动捕获，或是绑定到具备模板化的函数调用运算符的对象的场合中，可能尚有余热可以发挥
# 七、并发API
## 35.优先选用基于任务而非基于线程的程序设计
- std::thread的API未提供直接获取异步运行函数返回值的途径，而且如果那些函数抛出异常，程序就会终止
- 基于线程的程序设计要求手动管理线程耗尽、超订、负载均衡，以及新平台适应
- 经由应用了默认启动策略的std::async进行基于任务的程序设计，大部分这类问题（线程耗尽、超订、负载均衡、新平台等）都能找到解决之道
## 36.如果异步是必要的，则指定std::launch::async
- std::async的默认启动策略既允许任务以异步方式执行，也允许任务以同步方式执行
- 如此的弹性会导致使用thread_local变量时的不确定性，隐含着任务可能永远不会执行，还会影响运用了基于超时的wait调用的程序逻辑
- 如果异步是必要的，则指定std::launch::async
- std::async可以捕获到子线程的异常
- 默认执行策略和thread_local使用时会不明确thread_local变量使用的哪个线程的局部存储
## 37.使std::thread型别对象在所有路径皆不可联结
- 使std::thread型别对象在所有路径皆不可联结,即离开std::thread的作用域时std::thread.joinable()返回false
- 在析构时调用join可能导致难以调试的性能异常,因为调用join后线程必须正常执行完
- 在析构时调用detach可能导致难以调试的未定义行为,线程分离之后,使用的变量可能已经被销毁了
- 在成员列表的最后声明std::thread型别对象,因为成员变量以声明的顺序构造
- 不可联结的std::thread型别对象包括:
    - 默认构造的std::thread,没有可执行的函数
    - 已移动的std::thread
    - 已联结的std::thread,即调用过join()
    - 已分离的std::thread,即调用过detach()
## 38.对变化多端的线程句柄析构函数行为保持关注
```C++
// a+b的结果即不在pro(调用方)中保存也不在Add的作用域内保存(被调用方)
// a+b的结果是在一个共享状态中保存（堆内存），pro析构时会将这个共享状态的引用计数减一
void Add(int a, int b, std::promise<int>& result)
{
    result.set_value(a + b);
}
std::promise<int> pro;
std::thread t(Test, 1, 2, std::ref(pro));
```
```C++
// 1和2的表现是不一样的，
// 1没有接收返回值，所以会阻塞直到Task执行完
// 2接收了返回值，当返回值析构时，如果Task没有执行完才会阻塞直到Task执行完
void Task(){}
std::async(std::launch::async, Task);               // 1
auto result = std::async(std::launch::async, Task); // 2
```
## 39.考虑针对一次性事件通信使用以void为模板型别实参的期指
- 如果仅为了实现平凡事件通信，基于条件变量的设计会要求多余的互斥量，这会给相互关联的检测和反应任务带来约束，并要求反应任务校验事件确已发生
- 使用标志位（bool变量）的设计可以避免上述问题，但这一设计基于轮询而非阻塞
- 条件变量和标志位可以一起使用，但这样的通信机制设计结果不甚自然
- 使用std::promise型别对象和期值就可以回避这些问题，但是一来这个途径为了共享状态需要使用堆内存，而且仅限于一次性通信
## 40.对并发使用std::atomic，对特种内存使用volatile
- std::atomic用于多线程访问的数据，且不用互斥量。它是撰写并发软件的工具
- volatile用于读写操作不可以被优化掉的内存。它是在面对特种内存时使用的工具
- 简单理解：volatile用于告诉编译器不要对该关键字修饰的变量进行优化
# 八、微调
## 41.针对可复制的形参，在移动成本低并且一定会被复制的前提下，考虑将其按值传递
- 对于可复制的、在移动成本低廉的并且一定会被复制的形参而言，按值传递可能会和按引用传递具备相近的效率，并可能生成更少量的目标代码
- 经由构造复制形参的成本可能比经由赋值复制形参高出很多
- 按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递
## 42.考虑置入(emplace)而非插入(push,insert)
- 从原理上说，置入函数应该有比对应的插入函数高效，而且不应该有更低效的可能
- 从实践上说，置入函数在以下几个前提成立时，极有可能会运行得更快：
    - 待添加的值是以构造而非赋值方式加入容器
    - 传递的实参型别与容器持有之物的型别不同
    - 容器不会由于存在重复值而拒绝待添加的值
- 置入函数可能会执行在插入函数中会被拒绝的型别转换